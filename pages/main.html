<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AmkyawDev - Mining Card Game</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- Babylon.js (Game engine ·Ä°·Äî·Ä±·Äî·Ä≤·Ä∑ ·Äê·ÄÖ·Ä∫·ÄÅ·ÄØ·Äê·Ää·Ä∫·Ä∏·Äï·Ä≤·Äû·ÄØ·Ä∂·Ä∏) -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Poppins', sans-serif; }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 10;
            pointer-events: none;
        }
        #score-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 10;
            pointer-events: none;
        }
        .control-btn {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            color: #333;
            padding: 12px 30px;
            border-radius: 40px;
            font-weight: bold;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 20;
            transition: all 0.3s;
        }
        .control-btn:hover {
            transform: translateX(-50%) scale(1.05);
            background: #f0f0f0;
        }
        .back-btn {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: bold;
            border: 1px solid rgba(255,255,255,0.3);
            cursor: pointer;
            z-index: 20;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
            text-decoration: none;
        }
        .back-btn:hover {
            background: rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>
    <!-- UI Elements -->
    <div id="info-panel">
        üé¥ Mining Cards ¬∑ Click to Flip
    </div>
    <div id="score-panel">
        üíé Score: <span id="score-value">0</span>
    </div>
    
    <a href="../index.html" class="back-btn">
        ‚Üê Back to 3D Home
    </a>
    
    <button class="control-btn" id="dealBtn">
        üé≤ Deal New Cards
    </button>

    <!-- Babylon.js Canvas -->
    <canvas id="gameCanvas" style="width: 100%; height: 100%; outline: none;"></canvas>

    <script>
        // Telegram Web App
        const tg = window.Telegram.WebApp;
        tg.expand();
        tg.ready();
        
        // Back button
        tg.BackButton.show();
        tg.BackButton.onClick(function() {
            window.location.href = '../index.html';
        });

        // Babylon.js Engine Setup
        const canvas = document.getElementById('gameCanvas');
        const engine = new BABYLON.Engine(canvas, true);
        
        // Scene ·ÄÜ·Ä±·Ä¨·ÄÄ·Ä∫·Äô·Äö·Ä∫
        const scene = new BABYLON.Scene(engine);
        
        // Camera - ArcRotateCamera ·Äû·ÄØ·Ä∂·Ä∏·Äô·Äö·Ä∫ (·Äï·Äê·Ä∫·ÄÄ·Äº·Ää·Ä∑·Ä∫·Äú·Ä≠·ÄØ·Ä∑·Äõ·Ä°·Ä±·Ä¨·ÄÑ·Ä∫)
        const camera = new BABYLON.ArcRotateCamera(
            "camera", 
            -Math.PI / 2, Math.PI / 3, 
            15, 
            new BABYLON.Vector3(0, 2, 0), 
            scene
        );
        camera.attachControl(canvas, true);
        camera.lowerRadiusLimit = 8;
        camera.upperRadiusLimit = 20;
        camera.wheelPrecision = 50;
        
        // Lighting - ·Ä°·Äú·ÄÑ·Ä∫·Ä∏·Äõ·Ä±·Ä¨·ÄÑ·Ä∫
        // ·ÅÅ·Åã Hemispheric light (·Äï·Äê·Ä∫·Äù·Äî·Ä∫·Ä∏·ÄÄ·Äª·ÄÑ·Ä∫·Ä°·Äú·ÄÑ·Ä∫·Ä∏)
        const hemiLight = new BABYLON.HemisphericLight(
            "hemiLight", 
            new BABYLON.Vector3(0, 1, 0), 
            scene
        );
        hemiLight.intensity = 0.6;
        
        // ·ÅÇ·Åã Directional light (·Ä°·Äõ·Ä≠·Äï·Ä∫·Ä°·Äê·ÄΩ·ÄÄ·Ä∫)
        const dirLight = new BABYLON.DirectionalLight(
            "dirLight", 
            new BABYLON.Vector3(0.5, -1, 0.5), 
            scene
        );
        dirLight.position = new BABYLON.Vector3(5, 10, 5);
        dirLight.intensity = 0.8;
        
        // ·ÅÉ·Åã Point lights (·Ä°·Äõ·Ä±·Ä¨·ÄÑ·Ä∫·ÄÖ·ÄØ·Ä∂·Ä°·Äú·Äæ)
        const colors = [
            new BABYLON.Color3(0.2, 0.5, 1.0),  // ·Ä°·Äï·Äº·Ä¨
            new BABYLON.Color3(1.0, 0.3, 0.3),  // ·Ä°·Äî·ÄÆ
            new BABYLON.Color3(0.3, 1.0, 0.3),  // ·Ä°·ÄÖ·Ä≠·Äô·Ä∫·Ä∏
            new BABYLON.Color3(1.0, 0.8, 0.2)   // ·Ä°·Äù·Ä´
        ];
        
        const positions = [
            new BABYLON.Vector3(3, 1, 3),
            new BABYLON.Vector3(-3, 1, -3),
            new BABYLON.Vector3(3, 1, -3),
            new BABYLON.Vector3(-3, 1, 3)
        ];
        
        positions.forEach((pos, i) => {
            const light = new BABYLON.PointLight(`light${i}`, pos, scene);
            light.diffuse = colors[i];
            light.intensity = 0.5;
            
            // Light ·Äî·Ä±·Äõ·Ä¨·Äô·Äæ·Ä¨ ·Äô·ÄÆ·Ä∏·Äú·ÄØ·Ä∂·Ä∏·Äú·Ä±·Ä∏ ·Äë·Ää·Ä∑·Ä∫·Äô·Äö·Ä∫
            const sphere = BABYLON.MeshBuilder.CreateSphere(`lightSphere${i}`, { diameter: 0.2 }, scene);
            sphere.position = pos;
            const material = new BABYLON.StandardMaterial(`lightMat${i}`, scene);
            material.emissiveColor = colors[i];
            material.diffuseColor = colors[i];
            sphere.material = material;
        });

        // Ground (·Äô·Äº·Ä±·Äï·Äº·ÄÑ·Ä∫)
        const ground = BABYLON.MeshBuilder.CreateGround(
            "ground", 
            { width: 15, height: 15, subdivisions: 4 }, 
            scene
        );
        
        // Ground material
        const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
        groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.2);
        groundMat.specularColor = new BABYLON.Color3(0, 0, 0);
        groundMat.emissiveColor = new BABYLON.Color3(0.02, 0.02, 0.05);
        ground.material = groundMat;
        ground.position.y = -0.5;
        
        // Grid (·Äá·Äö·Ä¨·Ä∏·ÄÄ·ÄΩ·ÄÄ·Ä∫)
        const grid = BABYLON.MeshBuilder.CreateGround(
            "grid", 
            { width: 15, height: 15, subdivisions: 20 }, 
            scene
        );
        const gridMat = new BABYLON.StandardMaterial("gridMat", scene);
        gridMat.wireframe = true;
        gridMat.alpha = 0.3;
        gridMat.diffuseColor = new BABYLON.Color3(0.3, 0.6, 1.0);
        grid.material = gridMat;
        grid.position.y = -0.49;

        // Game Variables
        let cards = [];
        let score = 0;
        const scoreElement = document.getElementById('score-value');
        
        // ·Äñ·Ä≤·ÄÅ·Äª·Äï·Ä∫·Äê·ÄΩ·Ä± ·Äñ·Äî·Ä∫·Äê·ÄÆ·Ä∏·Äô·Äö·Ä∑·Ä∫ Function
        function createCard(position, color, isGold = false) {
            // Card body
            const card = BABYLON.MeshBuilder.CreateBox(
                "card", 
                { width: 1.2, height: 0.1, depth: 1.8 }, 
                scene
            );
            card.position = position;
            
            // Card material
            const mat = new BABYLON.StandardMaterial("cardMat", scene);
            if (isGold) {
                mat.diffuseColor = new BABYLON.Color3(1.0, 0.8, 0.2);
                mat.emissiveColor = new BABYLON.Color3(0.3, 0.2, 0.0);
                mat.specularColor = new BABYLON.Color3(1.0, 0.9, 0.5);
            } else {
                mat.diffuseColor = color;
                mat.emissiveColor = new BABYLON.Color3(0.1, 0.05, 0.1);
                mat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            }
            card.material = mat;
            
            // Add border (frame)
            const edgeMat = new BABYLON.StandardMaterial("edgeMat", scene);
            edgeMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            edgeMat.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            
            const edges = BABYLON.MeshBuilder.CreateLines("edges", {
                points: [
                    new BABYLON.Vector3(-0.6, 0.06, -0.9),
                    new BABYLON.Vector3(0.6, 0.06, -0.9),
                    new BABYLON.Vector3(0.6, 0.06, 0.9),
                    new BABYLON.Vector3(-0.6, 0.06, 0.9),
                    new BABYLON.Vector3(-0.6, 0.06, -0.9)
                ]
            }, scene);
            edges.color = new BABYLON.Color3(1, 1, 1);
            edges.position = position;
            
            return { card, edges, isGold };
        }

        // ·Äñ·Ä≤·ÄÅ·Äª·Äï·Ä∫·Äê·ÄΩ·Ä±·ÄÄ·Ä≠·ÄØ ·ÄÖ·ÄÆ·ÄÖ·Äâ·Ä∫·Äô·Äö·Ä∑·Ä∫ Function
        function dealCards() {
            // ·Ä°·Äü·Ä±·Ä¨·ÄÑ·Ä∫·Ä∏·Äê·ÄΩ·Ä±·ÄÄ·Ä≠·ÄØ ·Äñ·Äª·ÄÄ·Ä∫·Äô·Äö·Ä∫
            cards.forEach(c => {
                c.card.dispose();
                c.edges.dispose();
            });
            cards = [];
            
            const rows = 3;
            const cols = 4;
            const spacing = 2.2;
            const startX = - (cols - 1) * spacing / 2;
            const startZ = - (rows - 1) * spacing / 2;
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    // ·ÄÄ·Äª·Äï·Äî·Ä∫·Ä∏·Ä°·Äõ·Ä±·Ä¨·ÄÑ·Ä∫
                    const hue = Math.random() * 0.3 + 0.5; // purple-blue range
                    const color = new BABYLON.Color3(hue, 0.3, 0.8);
                    
                    // 20% ·ÄÄ ·Äõ·ÄΩ·Äæ·Ä±·Äõ·Ä±·Ä¨·ÄÑ·Ä∫ (·Ä°·Äë·Ä∞·Ä∏·ÄÜ·ÄØ)
                    const isGold = Math.random() < 0.2;
                    
                    const x = startX + j * spacing;
                    const z = startZ + i * spacing;
                    const y = 0;
                    
                    const card = createCard(new BABYLON.Vector3(x, y, z), color, isGold);
                    
                    // Card ·ÄÄ·Ä≠·ÄØ click ·Äú·Ä≠·ÄØ·Ä∑·Äõ·Ä°·Ä±·Ä¨·ÄÑ·Ä∫ action manager ·Äë·Ää·Ä∑·Ä∫·Äô·Äö·Ä∫
                    card.card.actionManager = new BABYLON.ActionManager(scene);
                    
                    // Pick action (·Äô·Ä±·Ä¨·ÄÄ·Ä∫·ÄÖ·Ä∫·Äî·Ä≤·Ä∑·Äë·Ä±·Ä¨·ÄÄ·Ä∫·Äê·Ä≤·Ä∑·Ä°·ÄÅ·Ä´)
                    card.card.actionManager.registerAction(
                        new BABYLON.ExecuteCodeAction(
                            BABYLON.ActionManager.OnPickTrigger,
                            function(evt) {
                                const sourceCard = evt.meshUnderPointer;
                                const cardData = cards.find(c => c.card === sourceCard);
                                if (cardData) {
                                    // ·Äñ·Ä≤·ÄÅ·Äª·Äï·Ä∫·ÄÄ·Ä≠·ÄØ ·Äú·Äæ·Äî·Ä∫·Äú·Ä≠·ÄØ·ÄÄ·Ä∫·Äô·Äö·Ä∫ (rotate)
                                    const rotateAnim = new BABYLON.Animation(
                                        "rotateAnim",
                                        "rotation.y",
                                        30,
                                        BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                                    );
                                    
                                    const keys = [];
                                    keys.push({ frame: 0, value: 0 });
                                    keys.push({ frame: 15, value: Math.PI });
                                    
                                    rotateAnim.setKeys(keys);
                                    sourceCard.animations = [];
                                    sourceCard.animations.push(rotateAnim);
                                    
                                    scene.beginAnimation(sourceCard, 0, 15, false);
                                    
                                    // ·Äõ·ÄΩ·Äæ·Ä±·Äñ·Ä≤·ÄÜ·Ä≠·ÄØ·Äõ·ÄÑ·Ä∫ score ·Äê·Ä≠·ÄØ·Ä∏·Äô·Äö·Ä∫
                                    if (cardData.isGold) {
                                        score += 10;
                                        scoreElement.textContent = score;
                                        
                                        // ·Äõ·ÄΩ·Äæ·Ä±·Äõ·Ä±·Ä¨·ÄÑ·Ä∫·ÄÖ·ÄÄ·Ä∫·Äù·Ä≠·ÄØ·ÄÑ·Ä∫·Ä∏·Äú·Ä±·Ä∏ ·Äë·Ää·Ä∑·Ä∫·Äô·Äö·Ä∫ (effect)
                                        const ring = BABYLON.MeshBuilder.CreateTorus(
                                            "ring", 
                                            { diameter: 1.5, thickness: 0.05 }, 
                                            scene
                                        );
                                        ring.position = sourceCard.position.clone();
                                        ring.position.y += 0.2;
                                        
                                        const ringMat = new BABYLON.StandardMaterial("ringMat", scene);
                                        ringMat.emissiveColor = new BABYLON.Color3(1, 0.8, 0);
                                        ringMat.diffuseColor = new BABYLON.Color3(1, 0.9, 0);
                                        ring.material = ringMat;
                                        
                                        // Ring ·Äï·Äª·Ä±·Ä¨·ÄÄ·Ä∫·Äû·ÄΩ·Ä¨·Ä∏·Ä°·Ä±·Ä¨·ÄÑ·Ä∫ animate
                                        setTimeout(() => {
                                            ring.dispose();
                                        }, 500);
                                    }
                                }
                            }
                        )
                    );
                    
                    cards.push(card);
                }
            }
        }

        // ·ÄÖ·Äê·Ä≤·Ä∑·Ä°·ÄÅ·Äª·Ä≠·Äî·Ä∫·Äô·Äæ·Ä¨ ·Äñ·Ä≤·ÄÅ·Äª·Äï·Ä∫·Äê·ÄΩ·Ä± ·ÄÅ·Äª·Äï·Ä±·Ä∏·Äô·Äö·Ä∫
        dealCards();

        // Deal button ·Äî·Äæ·Ä≠·Äï·Ä∫·Äõ·ÄÑ·Ä∫ ·Äñ·Ä≤·ÄÅ·Äª·Äï·Ä∫·Ä°·Äû·ÄÖ·Ä∫·ÄÅ·Äª·Äï·Ä±·Ä∏·Äô·Äö·Ä∫
        document.getElementById('dealBtn').addEventListener('click', () => {
            score = 0;
            scoreElement.textContent = score;
            dealCards();
        });

        // Render loop
        engine.runRenderLoop(() => {
            // ·Äñ·Ä≤·ÄÅ·Äª·Äï·Ä∫·Äê·ÄΩ·Ä±·ÄÄ·Ä≠·ÄØ ·Äî·Ää·Ä∫·Ä∏·Äî·Ää·Ä∫·Ä∏·Äú·Ä±·Ä∏ floating ·Äú·ÄØ·Äï·Ä∫·Äô·Äö·Ä∫
            cards.forEach((c, index) => {
                c.card.position.y = Math.sin(Date.now() * 0.002 + index) * 0.1;
                c.edges.position.y = c.card.position.y;
            });
            
            scene.render();
        });

        // Window resize handler
        window.addEventListener('resize', () => {
            engine.resize();
        });
    </script>
</body>
  </html>
